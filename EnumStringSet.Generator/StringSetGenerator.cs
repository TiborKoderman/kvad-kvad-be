using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

[Generator]
public class StringSetGenerator : IIncrementalGenerator
{
  public void Initialize(IncrementalGeneratorInitializationContext context)
  {
    // Find all enums decorated with StringSetAttribute
    var enumDeclarations = context.SyntaxProvider
        .CreateSyntaxProvider(
            predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
            transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
        .Where(static m => m is not null);

    // Combine with compilation
    var compilationAndEnums = context.CompilationProvider.Combine(enumDeclarations.Collect());

    // Register source output
    context.RegisterSourceOutput(compilationAndEnums,
        static (spc, source) => Execute(source.Left, source.Right, spc));
  }

  private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
  {
    return node is EnumDeclarationSyntax enumDecl
        && enumDecl.AttributeLists.Count > 0;
  }

  private static EnumToGenerate? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
  {
    var enumDeclarationSyntax = (EnumDeclarationSyntax)context.Node;

    // Get the semantic model
    var enumSymbol = context.SemanticModel.GetDeclaredSymbol(enumDeclarationSyntax);
    if (enumSymbol is not INamedTypeSymbol enumTypeSymbol)
      return null;

    // Check if it has the StringSet attribute
    var hasStringSetAttribute = enumTypeSymbol.GetAttributes()
        .Any(ad => ad.AttributeClass?.Name == "StringSetAttribute");

    if (!hasStringSetAttribute)
      return null;

    // Get attribute parameters
    var stringSetAttribute = enumTypeSymbol.GetAttributes()
        .First(ad => ad.AttributeClass?.Name == "StringSetAttribute");

    var format = StringFormatting.CapitalizedKebabCase;
    if (stringSetAttribute.ConstructorArguments.Length > 0)
    {
      if (stringSetAttribute.ConstructorArguments[0].Value is int formatValue)
      {
        format = (StringFormatting)formatValue;
      }
    }

    // Get enum values
    var enumValues = enumTypeSymbol.GetMembers()
        .OfType<IFieldSymbol>()
        .Where(f => f.IsConst)
        .Select(f => f.Name)
        .ToList();

    return new EnumToGenerate(
        Name: enumTypeSymbol.Name,
        Namespace: enumTypeSymbol.ContainingNamespace.ToDisplayString(),
        Values: enumValues,
        Format: format);
  }

  private static void Execute(Compilation compilation, ImmutableArray<EnumToGenerate?> enums, SourceProductionContext context)
  {
    if (enums.IsDefaultOrEmpty)
      return;

    // Generate the attribute first
    GenerateStringSetAttribute(context);

    // Generate wrapper classes for each enum
    foreach (var enumToGenerate in enums)
    {
      if (enumToGenerate is null)
        continue;

      GenerateEnumWrapper(enumToGenerate, context);
    }
  }

  private static void GenerateStringSetAttribute(SourceProductionContext context)
  {
    var sourceText = SourceText.From("""
            // <auto-generated/>
            using System;

            namespace EnumStringSet
            {
                [AttributeUsage(AttributeTargets.Enum)]
                public class StringSetAttribute : Attribute
                {
                    public StringFormatting Format { get; init; } = StringFormatting.CapitalizedKebabCase;
                    
                    public StringSetAttribute() { }
                    
                    public StringSetAttribute(StringFormatting format)
                    {
                        Format = format;
                    }
                }

                public enum StringFormatting
                {
                    CapitalizedKebabCase,
                    LowercaseKebabCase,
                    SnakeCase,
                    AsIs
                }
            }
            """, Encoding.UTF8);

    context.AddSource("StringSetAttribute.g.cs", sourceText);
  }

  private static void GenerateEnumWrapper(EnumToGenerate enumToGenerate, SourceProductionContext context)
  {
    var sb = new StringBuilder();

    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("using System;");
    sb.AppendLine();

    if (!string.IsNullOrEmpty(enumToGenerate.Namespace) && enumToGenerate.Namespace != "<global namespace>")
    {
      sb.AppendLine($"namespace {enumToGenerate.Namespace}");
      sb.AppendLine("{");
    }

    // Generate wrapper struct
    sb.AppendLine($"    /// <summary>");
    sb.AppendLine($"    /// Generated wrapper for {enumToGenerate.Name} enum with implicit string conversion");
    sb.AppendLine($"    /// </summary>");
    sb.AppendLine($"    public readonly struct {enumToGenerate.Name}String");
    sb.AppendLine("    {");
    sb.AppendLine($"        private readonly {enumToGenerate.Name} _value;");
    sb.AppendLine();
    sb.AppendLine($"        private {enumToGenerate.Name}String({enumToGenerate.Name} value) => _value = value;");
    sb.AppendLine();

    // Generate static properties for each enum value
    foreach (var enumValue in enumToGenerate.Values)
    {
      var formattedValue = FormatEnumValue(enumValue, enumToGenerate.Format);
      sb.AppendLine($"        public static {enumToGenerate.Name}String {enumValue} => new({enumToGenerate.Name}.{enumValue});");
    }

    sb.AppendLine();

    // Generate implicit operators
    sb.AppendLine($"        public static implicit operator string({enumToGenerate.Name}String value)");
    sb.AppendLine("        {");
    sb.AppendLine("            return value._value switch");
    sb.AppendLine("            {");

    foreach (var enumValue in enumToGenerate.Values)
    {
      var formattedValue = FormatEnumValue(enumValue, enumToGenerate.Format);
      sb.AppendLine($"                {enumToGenerate.Name}.{enumValue} => \"{formattedValue}\",");
    }

    sb.AppendLine($"                _ => value._value.ToString()");
    sb.AppendLine("            };");
    sb.AppendLine("        }");
    sb.AppendLine();

    sb.AppendLine($"        public static implicit operator {enumToGenerate.Name}({enumToGenerate.Name}String value) => value._value;");
    sb.AppendLine($"        public static implicit operator {enumToGenerate.Name}String({enumToGenerate.Name} value) => new(value);");
    sb.AppendLine();

    sb.AppendLine("        public override string ToString() => this;");
    sb.AppendLine("    }");
    sb.AppendLine();

    // Generate static helper class
    sb.AppendLine($"    /// <summary>");
    sb.AppendLine($"    /// Static helper class for {enumToGenerate.Name} with direct string access");
    sb.AppendLine($"    /// </summary>");
    sb.AppendLine($"    public static class {enumToGenerate.Name}Strings");
    sb.AppendLine("    {");

    foreach (var enumValue in enumToGenerate.Values)
    {
      var formattedValue = FormatEnumValue(enumValue, enumToGenerate.Format);
      sb.AppendLine($"        public static string {enumValue} => \"{formattedValue}\";");
    }

    sb.AppendLine("    }");

    if (!string.IsNullOrEmpty(enumToGenerate.Namespace) && enumToGenerate.Namespace != "<global namespace>")
    {
      sb.AppendLine("}");
    }

    var sourceText = SourceText.From(sb.ToString(), Encoding.UTF8);
    context.AddSource($"{enumToGenerate.Name}String.g.cs", sourceText);
  }

  private static string FormatEnumValue(string enumValue, StringFormatting format)
  {
    return format switch
    {
      StringFormatting.CapitalizedKebabCase => ToCapitalizedKebabCase(enumValue),
      StringFormatting.LowercaseKebabCase => ToCapitalizedKebabCase(enumValue).ToLowerInvariant(),
      StringFormatting.SnakeCase => ToSnakeCase(enumValue),
      StringFormatting.AsIs => enumValue,
      _ => enumValue
    };
  }

  private static string ToCapitalizedKebabCase(string input)
  {
    if (string.IsNullOrEmpty(input))
      return input;

    var result = new StringBuilder();
    for (int i = 0; i < input.Length; i++)
    {
      var current = input[i];
      if (i > 0 && char.IsUpper(current))
      {
        result.Append('-');
      }
      result.Append(current);
    }
    return result.ToString();
  }

  private static string ToSnakeCase(string input)
  {
    if (string.IsNullOrEmpty(input))
      return input;

    var result = new StringBuilder();
    for (int i = 0; i < input.Length; i++)
    {
      var current = input[i];
      if (i > 0 && char.IsUpper(current))
      {
        result.Append('_');
      }
      result.Append(char.ToLowerInvariant(current));
    }
    return result.ToString();
  }
}

// Data structure to hold enum information
public record EnumToGenerate(
    string Name,
    string Namespace,
    List<string> Values,
    StringFormatting Format);

public enum StringFormatting
{
  CapitalizedKebabCase,
  LowercaseKebabCase,
  SnakeCase,
  AsIs
}
